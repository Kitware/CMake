#
#
project(libarchive C)
#
cmake_minimum_required(VERSION 2.8 FATAL_ERROR)
set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/build/cmake")
if(NOT CMAKE_RUNTIME_OUTPUT_DIRECTORY)
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${libarchive_BINARY_DIR}/bin)
endif()

# On MacOS, prefer MacPorts libraries to system libraries.
# I haven't come up with a compelling argument for this to be conditional.
list(APPEND CMAKE_PREFIX_PATH /opt/local)

#
# Version - read from 'version' file.
#
file(STRINGS ${CMAKE_CURRENT_SOURCE_DIR}/build/version _version)
string(REGEX REPLACE
 "^([0-9])[0-9][0-9][0-9][0-9][0-9][0-9][a-z]?$" "\\1" _major ${_version})
string(REGEX REPLACE
 "^[0-9]([0-9][0-9][0-9])[0-9][0-9][0-9][a-z]?$" "\\1" _minor ${_version})
string(REGEX REPLACE
 "^[0-9][0-9][0-9][0-9]([0-9][0-9][0-9])[a-z]?$" "\\1" _revision ${_version})
string(REGEX REPLACE
 "^[0-9][0-9][0-9][0-9][0-9][0-9][0-9]([a-z]?)$" "\\1" _quality ${_version})
set(_version_number ${_major}${_minor}${_revision})
string(REGEX REPLACE "[0]*([^0]*[0-9])$" "\\1" _trimmed_minor ${_minor})
string(REGEX REPLACE "[0]*([^0]*[0-9])$" "\\1" _trimmed_revision ${_revision})
#
set(VERSION                    "${_major}.${_trimmed_minor}.${_trimmed_revision}${_quality}")
set(BSDCPIO_VERSION_STRING     "${VERSION}")
set(BSDTAR_VERSION_STRING      "${VERSION}")
set(LIBARCHIVE_VERSION_NUMBER  "${_version_number}")
set(LIBARCHIVE_VERSION_STRING  "${VERSION}")

# INTERFACE_VERSION increments with every release
# libarchive 2.7 == interface version 9 = 2 + 7
# libarchive 2.8 == interface version 10 = 2 + 8
# libarchive 2.9 == interface version 11 = 2 + 9
# libarchive 3.0 == interface version 12
# libarchive 3.x == interface version 12 + x
math(EXPR INTERFACE_VERSION  "12 + ${_minor}")

# Set SOVERSION == Interface version
# ?? Should there be more here ??
set(SOVERSION "${INTERFACE_VERSION}")

# Disable warnings to avoid changing 3rd party code.
if("${CMAKE_C_COMPILER_ID}" MATCHES
    "^(GNU|Clang|XL|VisualAge|SunPro|MIPSpro|HP|Intel)$")
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -w")
elseif("${CMAKE_C_COMPILER_ID}" MATCHES "^(PathScale)$")
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -woffall")
elseif(BORLAND)
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -w-")
endif()

# Enable CTest/CDash support
include(CTest)

option(ENABLE_NETTLE "Enable use of Nettle" ON)
option(ENABLE_OPENSSL "Enable use of OpenSSL" ON)
option(ENABLE_XATTR "Enable extended attribute support" ON)
option(ENABLE_ACL "Enable ACL support" ON)
option(ENABLE_ICONV "Enable iconv support" ON)

if(WIN32)
  if(MSVC60)
    set(WINVER 0x0400)
  else()
    set(WINVER 0x0500)
  endif()
  set(_WIN32_WINNT ${WINVER})
endif(WIN32)

if("${CMAKE_C_PLATFORM_ID}" MATCHES "^(HP-UX)$")
  add_definitions(-D_XOPEN_SOURCE=500) # Ask wchar.h for mbstate_t
endif()

#
include(CheckCSourceCompiles)
include(CheckCSourceRuns)
include(CheckFileOffsetBits)
include(CheckFuncs)
include(CheckHeaderDirent)
include(CheckIncludeFile)
include(CheckIncludeFiles)
include(CheckLibraryExists)
include(CheckStructMember)
include(CheckSymbolExists)
include(CheckTypeExists)
include(CheckTypeSize)

#
# Generate list.h
#
macro(GENERATE_LIST_H _listfile _cmlist __list_sources)
  set(_argv ${ARGV})
  # Remove _listfile and _cmlist from _argv
  list(REMOVE_AT _argv 0 1)
  if(NOT EXISTS "${_listfile}" OR
     ${_cmlist} IS_NEWER_THAN "${_listfile}")

    message(STATUS "Generating ${_listfile}")
    file(WRITE ${_listfile} "")
    foreach(testfile ${_argv})
      if(testfile MATCHES "^test_[^/]+[.]c$")
        file(STRINGS ${testfile} testvar REGEX "^DEFINE_TEST")
        foreach(deftest ${testvar})
          file(APPEND ${_listfile} "${deftest}\n")
        endforeach(deftest)
      endif(testfile MATCHES "^test_[^/]+[.]c$")
    endforeach(testfile)

  endif(NOT EXISTS "${_listfile}" OR
     ${_cmlist} IS_NEWER_THAN "${_listfile}")
endmacro(GENERATE_LIST_H)
#
# Generate installation rules for man pages.
#
macro(INSTALL_MAN __mans)
  foreach(_man ${ARGV})
    string(REGEX REPLACE "^.+[.]([1-9])" "\\1" _mansect ${_man})
    install(FILES ${_man} DESTINATION "share/man/man${_mansect}")
  endforeach(_man)
endmacro(INSTALL_MAN __mans)

#
# Check compress/decompress libraries
#
if(WIN32 AND NOT CMAKE_CL_64 AND NOT CYGWIN)
  # GnuWin32 is only for Win32, not Win64.
  set(__GNUWIN32PATH "C:/Program Files/GnuWin32")
endif(WIN32 AND NOT CMAKE_CL_64 AND NOT CYGWIN)
if(DEFINED __GNUWIN32PATH AND EXISTS "${__GNUWIN32PATH}")
  # You have to add a path availabel DLL file into PATH environment variable.
  # Maybe DLL path is "C:/Program Files/GnuWin32/bin".
  # The zlib and the bzip2 Setup program have installed programs and DLLs into
  # "C:/Program Files/GnuWin32" by default.
  # This is convenience setting for Windows.
  set(CMAKE_PREFIX_PATH ${__GNUWIN32PATH} $(CMAKE_PREFIX_PATH))
  #
  # If you didn't use Setup program or installed into nonstandard path,
  # cmake cannot find out your zlib or bzip2 libraries and include files,
  # you should execute cmake with  -DCMAKE_PREFIX_PATH option.
  #   e.g.
  #     cmake -DCMAKE_PREFIX_PATH=<your-GnuWin32-path> <path-to-source>
  #
  # If compiling error occured in zconf.h, You may need patch to zconf.h.
  #--- zconf.h.orig	2005-07-21 00:40:26.000000000
  #+++ zconf.h	2009-01-19 11:39:10.093750000
  #@@ -286,7 +286,7 @@
  #
  # #if 1           /* HAVE_UNISTD_H -- this line is updated by ./configure */
  # #  include <sys/types.h> /* for off_t */
  #-#  include <unistd.h>    /* for SEEK_* and off_t */
  #+#  include <stdio.h>    /* for SEEK_* and off_t */
  # #  ifdef VMS
  # #    include <unixio.h>   /* for off_t */
  # #  endif
endif(DEFINED __GNUWIN32PATH AND EXISTS "${__GNUWIN32PATH}")

set(ADDITIONAL_LIBS "")
#
# Find ZLIB
#
find_package(ZLIB)
if(ZLIB_FOUND)
  set(HAVE_LIBZ 1)
  set(HAVE_ZLIB_H 1)
  include_directories(${ZLIB_INCLUDE_DIR})
  list(APPEND ADDITIONAL_LIBS ${ZLIB_LIBRARIES})
  if(WIN32 AND NOT CYGWIN)
    set(CMAKE_REQUIRED_INCLUDES ${ZLIB_INCLUDE_DIR})
    set(CMAKE_REQUIRED_LIBRARIES ${ZLIB_LIBRARIES})
    CHECK_C_SOURCE_Runs(
      "#ifndef ZLIB_WINAPI\n#define ZLIB_WINAPI\n#endif\n#include <zlib.h>\nint main() {uLong f = zlibCompileFlags(); return (f&(1U<<10))?0:-1; }"
      ZLIB_WINAPI)
    set(CMAKE_REQUIRED_INCLUDES)
    set(CMAKE_REQUIRED_LIBRARIES)
  endif(WIN32 AND NOT CYGWIN)
else(ZLIB_FOUND)
  message(FATAL_ERROR "CMake requires zlib to be available to libarchive")
endif(ZLIB_FOUND)
#
# Find BZip2
#
find_package(BZip2)
if(BZIP2_FOUND)
  set(HAVE_LIBBZ2 1)
  set(HAVE_BZLIB_H 1)
  include_directories(${BZIP2_INCLUDE_DIR})
  list(APPEND ADDITIONAL_LIBS ${BZIP2_LIBRARIES})
endif(BZIP2_FOUND)
mark_as_advanced(CLEAR BZIP2_INCLUDE_DIR)
mark_as_advanced(CLEAR BZIP2_LIBRARY)

if(0) # CMake does not need LZMA support in libarchive
#
# Find LZMA
#
find_package(LZMA)
if(LZMA_FOUND)
  set(HAVE_LIBLZMA 1)
  set(HAVE_LZMA_H 1)
  include_directories(${LZMA_INCLUDE_DIR})
  list(APPEND ADDITIONAL_LIBS ${LZMA_LIBRARIES})
elseif(LZMADEC_FOUND)
  set(HAVE_LIBLZMADEC 1)
  set(HAVE_LZMADEC_H 1)
  include_directories(${LZMADEC_INCLUDE_DIR})
  list(APPEND ADDITIONAL_LIBS ${LZMADEC_LIBRARIES})
endif(LZMA_FOUND)
endif()

#
# Check headers
#
CHECK_HEADER_DIRENT()

set(INCLUDES "")
macro(LA_CHECK_INCLUDE_FILE header var)
      CHECK_INCLUDE_FILES("${INCLUDES};${header}" ${var})
      if(${var})
      	 set(INCLUDES ${INCLUDES} ${header})
      endif(${var})
endmacro(LA_CHECK_INCLUDE_FILE)

# Some FreeBSD headers assume sys/types.h was already included.
LA_CHECK_INCLUDE_FILE("sys/types.h" HAVE_SYS_TYPES_H)

# Alphabetize the rest unless there's a compelling reason
LA_CHECK_INCLUDE_FILE("acl/libacl.h" HAVE_ACL_LIBACL_H)
LA_CHECK_INCLUDE_FILE("ctype.h" HAVE_CTYPE_H)
LA_CHECK_INCLUDE_FILE("copyfile.h" HAVE_COPYFILE_H)
LA_CHECK_INCLUDE_FILE("direct.h" HAVE_DIRECT_H)
LA_CHECK_INCLUDE_FILE("dlfcn.h" HAVE_DLFCN_H)
LA_CHECK_INCLUDE_FILE("errno.h" HAVE_ERRNO_H)
LA_CHECK_INCLUDE_FILE("ext2fs/ext2_fs.h" HAVE_EXT2FS_EXT2_FS_H)

CHECK_C_SOURCE_COMPILES("#include <sys/ioctl.h>
#include <ext2fs/ext2_fs.h>
int main(void) { return EXT2_IOC_GETFLAGS; }" HAVE_WORKING_EXT2_IOC_GETFLAGS)

LA_CHECK_INCLUDE_FILE("fcntl.h" HAVE_FCNTL_H)
LA_CHECK_INCLUDE_FILE("grp.h" HAVE_GRP_H)
LA_CHECK_INCLUDE_FILE("inttypes.h" HAVE_INTTYPES_H)
LA_CHECK_INCLUDE_FILE("io.h" HAVE_IO_H)
LA_CHECK_INCLUDE_FILE("langinfo.h" HAVE_LANGINFO_H)
LA_CHECK_INCLUDE_FILE("limits.h" HAVE_LIMITS_H)
LA_CHECK_INCLUDE_FILE("linux/types.h" HAVE_LINUX_TYPES_H)
LA_CHECK_INCLUDE_FILE("linux/fiemap.h" HAVE_LINUX_FIEMAP_H)
LA_CHECK_INCLUDE_FILE("linux/fs.h" HAVE_LINUX_FS_H)
LA_CHECK_INCLUDE_FILE("linux/magic.h" HAVE_LINUX_MAGIC_H)
LA_CHECK_INCLUDE_FILE("locale.h" HAVE_LOCALE_H)
LA_CHECK_INCLUDE_FILE("memory.h" HAVE_MEMORY_H)
LA_CHECK_INCLUDE_FILE("paths.h" HAVE_PATHS_H)
LA_CHECK_INCLUDE_FILE("poll.h" HAVE_POLL_H)
LA_CHECK_INCLUDE_FILE("process.h" HAVE_PROCESS_H)
LA_CHECK_INCLUDE_FILE("pwd.h" HAVE_PWD_H)
LA_CHECK_INCLUDE_FILE("regex.h" HAVE_REGEX_H)
LA_CHECK_INCLUDE_FILE("signal.h" HAVE_SIGNAL_H)
LA_CHECK_INCLUDE_FILE("stdarg.h" HAVE_STDARG_H)
LA_CHECK_INCLUDE_FILE("stdint.h" HAVE_STDINT_H)
LA_CHECK_INCLUDE_FILE("stdlib.h" HAVE_STDLIB_H)
LA_CHECK_INCLUDE_FILE("string.h" HAVE_STRING_H)
LA_CHECK_INCLUDE_FILE("strings.h" HAVE_STRINGS_H)
LA_CHECK_INCLUDE_FILE("sys/acl.h" HAVE_SYS_ACL_H)
LA_CHECK_INCLUDE_FILE("sys/cdefs.h" HAVE_SYS_CDEFS_H)
LA_CHECK_INCLUDE_FILE("sys/ioctl.h" HAVE_SYS_IOCTL_H)
LA_CHECK_INCLUDE_FILE("sys/mkdev.h" HAVE_SYS_MKDEV_H)
LA_CHECK_INCLUDE_FILE("sys/mount.h" HAVE_SYS_MOUNT_H)
LA_CHECK_INCLUDE_FILE("sys/param.h" HAVE_SYS_PARAM_H)
LA_CHECK_INCLUDE_FILE("sys/poll.h" HAVE_SYS_POLL_H)
LA_CHECK_INCLUDE_FILE("sys/select.h" HAVE_SYS_SELECT_H)
LA_CHECK_INCLUDE_FILE("sys/stat.h" HAVE_SYS_STAT_H)
LA_CHECK_INCLUDE_FILE("sys/statfs.h" HAVE_SYS_STATFS_H)
LA_CHECK_INCLUDE_FILE("sys/statvfs.h" HAVE_SYS_STATVFS_H)
LA_CHECK_INCLUDE_FILE("sys/time.h" HAVE_SYS_TIME_H)
LA_CHECK_INCLUDE_FILE("sys/utime.h" HAVE_SYS_UTIME_H)
LA_CHECK_INCLUDE_FILE("sys/utsname.h" HAVE_SYS_UTSNAME_H)
LA_CHECK_INCLUDE_FILE("sys/vfs.h" HAVE_SYS_VFS_H)
LA_CHECK_INCLUDE_FILE("sys/wait.h" HAVE_SYS_WAIT_H)
LA_CHECK_INCLUDE_FILE("time.h" HAVE_TIME_H)
LA_CHECK_INCLUDE_FILE("unistd.h" HAVE_UNISTD_H)
LA_CHECK_INCLUDE_FILE("utime.h" HAVE_UTIME_H)
LA_CHECK_INCLUDE_FILE("wchar.h" HAVE_WCHAR_H)
LA_CHECK_INCLUDE_FILE("wctype.h" HAVE_WCTYPE_H)
LA_CHECK_INCLUDE_FILE("windows.h" HAVE_WINDOWS_H)
# Following files need windwos.h, so we should test it after windows.h test.
LA_CHECK_INCLUDE_FILE("wincrypt.h" HAVE_WINCRYPT_H)
LA_CHECK_INCLUDE_FILE("winioctl.h" HAVE_WINIOCTL_H)

#
# Check whether use of __EXTENSIONS__ is safe.
# We need some macro such as _GNU_SOURCE to use extension functions.
#
set(_INCLUDE_FILES)
foreach(it ${_HEADER})
   set(_INCLUDE_FILES "${_INCLUDE_FILES}#include <${it}>\n")
endforeach(it)

CHECK_C_SOURCE_COMPILES(
  "#define __EXTENSIONS__ 1
   ${_INCLUDE_FILES}
   int main() { return 0;}"
 SAFE_TO_DEFINE_EXTENSIONS)

#
# Find Nettle
#
if(ENABLE_NETTLE)
  CHECK_LIBRARY_EXISTS(nettle "nettle_sha1_digest" "" NETTLE_FOUND)
  if(NETTLE_FOUND)
    set(CMAKE_REQUIRED_LIBRARIES "nettle")
    find_library(NETTLE_LIBRARY NAMES nettle)
    list(APPEND ADDITIONAL_LIBS ${NETTLE_LIBRARY})
  else(NETTLE_FOUND)
    set(ENABLE_NETTLE OFF)
  endif(NETTLE_FOUND)
endif(ENABLE_NETTLE)

#
# Find OpenSSL
# (Except on Mac, where OpenSSL is deprecated.)
#
if(ENABLE_OPENSSL AND NOT CMAKE_SYSTEM_NAME MATCHES "Darwin")
  find_package(OpenSSL)
else()
  set(OPENSSL_FOUND FALSE) # Override cached value
endif()

# FreeBSD libmd
CHECK_LIBRARY_EXISTS(md "MD5Init" "" LIBMD_FOUND)
if(LIBMD_FOUND)
  set(CMAKE_REQUIRED_LIBRARIES "md")
  find_library(LIBMD_LIBRARY NAMES md)
  list(APPEND ADDITIONAL_LIBS ${LIBMD_LIBRARY})
endif(LIBMD_FOUND)

#
# How to prove that CRYPTO functions, which have several names on various
# platforms, just see if archive_crypto.c can compile and link against
# required libraries.
#
macro(CHECK_CRYPTO ALGORITHMS IMPLEMENTATION)
    if(HAVE_SYS_TYPES_H)
        set(CRYPTO_HEADER_CONFIG "#define HAVE_SYS_TYPES_H 1\n")
    else(HAVE_SYS_TYPES_H)
        set(CRYPTO_HEADER_CONFIG "")
    endif(HAVE_SYS_TYPES_H)

    foreach(ALGORITHM ${ALGORITHMS})
      string(TOLOWER "${ALGORITHM}" lower_algorithm)
      string(TOUPPER "${ALGORITHM}" algorithm)
      if("${IMPLEMENTATION}" MATCHES "^OPENSSL$" AND NOT OPENSSL_FOUND)
        set(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION} FALSE)
      elseif("${IMPLEMENTATION}" MATCHES "^NETTLE$" AND NOT NETTLE_FOUND)
        set(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION} FALSE)
      endif("${IMPLEMENTATION}" MATCHES "^OPENSSL$" AND NOT OPENSSL_FOUND)

      if(NOT DEFINED ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION})
        # Probe the local implementation for whether this
	# crypto implementation is available on this platform.
	set(TRY_CRYPTO_REQUIRED_INCLUDES
	  "-DINCLUDE_DIRECTORIES:STRING=${CMAKE_CURRENT_SOURCE_DIR}/libarchive;${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp")
	set(TRY_CRYPTO_REQUIRED_LIBS)
	if("${IMPLEMENTATION}" MATCHES "^OPENSSL$" AND OPENSSL_FOUND)
	    set(TRY_CRYPTO_REQUIRED_INCLUDES
	      "${TRY_CRYPTO_REQUIRED_INCLUDES};${OPENSSL_INCLUDE_DIR}")
	    set(TRY_CRYPTO_REQUIRED_LIBS
	        "-DLINK_LIBRARIES:STRING=${OPENSSL_LIBRARIES}")
	elseif("${IMPLEMENTATION}" MATCHES "^NETTLE$" AND NETTLE_FOUND)
	    set(TRY_CRYPTO_REQUIRED_LIBS
	        "-DLINK_LIBRARIES:STRING=${NETTLE_LIBRARY}")
	elseif("${IMPLEMENTATION}" MATCHES "^LIBMD$" AND LIBMD_FOUND)
	    set(TRY_CRYPTO_REQUIRED_LIBS
	        "-DLINK_LIBRARIES:STRING=${LIBMD_LIBRARY}")
	endif("${IMPLEMENTATION}" MATCHES "^OPENSSL$" AND OPENSSL_FOUND)

	file(READ "${CMAKE_CURRENT_SOURCE_DIR}/libarchive/archive_crypto.c"
	     ARCHIVE_CRYPTO_C)

	set(SOURCE "
#define ARCHIVE_${algorithm}_COMPILE_TEST
#define ARCHIVE_CRYPTO_${algorithm}_${IMPLEMENTATION}
#define PLATFORM_CONFIG_H \"check_crypto_md.h\"

${ARCHIVE_CRYPTO_C}

int
main(int argc, char **argv)
{
  archive_${lower_crypto}_ctx ctx;
  archive_${lower_crypto}_init(&ctx);
  archive_${lower_crypto}_update(&ctx, *argv, argc);
  archive_${lower_crypto}_final(&ctx, NULL);
  return 0;
}
")

  file(WRITE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/check_crypto_md.h" "")
	file(WRITE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/check_crypto_md.c" "${SOURCE}")
	message(STATUS "Checking support for ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION}")

	try_compile(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION}
	  ${CMAKE_BINARY_DIR}
	  ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/check_crypto_md.c
	  CMAKE_FLAGS
	   "${TRY_CRYPTO_REQUIRED_LIBS}"
	   "${TRY_CRYPTO_REQUIRED_INCLUDES}"
	  OUTPUT_VARIABLE OUTPUT)

	# Inform user whether or not we found it; if not, log why we didn't.
        if(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION})
          message(STATUS "Checking support for ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION} -- found")
        else(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION})
          message(STATUS "Checking support for ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION} -- not found")
          file(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log
    	    "Checking support for ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION} failed with the following output:\n"
    	    "${OUTPUT}\n"
    	    "Source file was:\n${SOURCE}\n")
        endif(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION})
      endif(NOT DEFINED ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION})

      # Add appropriate libs/includes depending on whether the implementation
      # was found on this platform.
      if(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION})
        if("${IMPLEMENTATION}" MATCHES "^OPENSSL$" AND OPENSSL_FOUND)
          include_directories(${OPENSSL_INCLUDE_DIR})
	  list(APPEND ADDITIONAL_LIBS ${OPENSSL_LIBRARIES})
	   list(REMOVE_DUPLICATES ADDITIONAL_LIBS)
        endif("${IMPLEMENTATION}" MATCHES "^OPENSSL$" AND OPENSSL_FOUND)
      endif(ARCHIVE_CRYPTO_${ALGORITHM}_${IMPLEMENTATION})
    endforeach(ALGORITHM ${ALGORITHMS})
endmacro(CHECK_CRYPTO ALGORITHMS IMPLEMENTATION)

#
# CRYPTO functions on Windows is defined at archive_windows.c, thus we do not
# need the test what the functions can be mapped to archive_{crypto name}_init,
# archive_{crypto name}_update and archive_{crypto name}_final.
# The functions on Windows use CALG_{crypto name} macro to create a crypt object
# and then we need to know what CALG_{crypto name} macros is available to show
# ARCHIVE_CRYPTO_{crypto name}_WIN macros because Windows 2000 and earlier version
# of Windows XP do not support SHA256, SHA384 and SHA512.
#
macro(CHECK_CRYPTO_WIN CRYPTO_LIST)
  if(WIN32 AND NOT CYGWIN)
    foreach(CRYPTO ${CRYPTO_LIST})
      if(NOT DEFINED ARCHIVE_CRYPTO_${CRYPTO}_WIN)
	string(TOUPPER "${CRYPTO}" crypto)
	set(ALGID "")
	if("${CRYPTO}" MATCHES "^MD5$")
	    set(ALGID "CALG_MD5")
	endif("${CRYPTO}" MATCHES "^MD5$")
	if("${CRYPTO}" MATCHES "^SHA1$")
	    set(ALGID "CALG_SHA1")
	endif("${CRYPTO}" MATCHES "^SHA1$")
	if("${CRYPTO}" MATCHES "^SHA256$")
	    set(ALGID "CALG_SHA_256")
	endif("${CRYPTO}" MATCHES "^SHA256$")
	if("${CRYPTO}" MATCHES "^SHA384$")
	    set(ALGID "CALG_SHA_384")
	endif("${CRYPTO}" MATCHES "^SHA384$")
	if("${CRYPTO}" MATCHES "^SHA512$")
	    set(ALGID "CALG_SHA_512")
	endif("${CRYPTO}" MATCHES "^SHA512$")

	set(SOURCE "#define ${crypto}_COMPILE_TEST
#define _WIN32_WINNT ${_WIN32_WINNT}
#define WINVER ${WINVER}
#include <windows.h>
#include <wincrypt.h>

int
main(int argc, char **argv)
{
	return ${ALGID};
}
")
	set(SOURCE_FILE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/check_crypto_win.c")

	file(WRITE "${SOURCE_FILE}" "${SOURCE}")
	message(STATUS "Checking support for ARCHIVE_CRYPTO_${CRYPTO}_WIN")

	try_compile(ARCHIVE_CRYPTO_${CRYPTO}_WIN
	  ${CMAKE_BINARY_DIR}
	  ${SOURCE_FILE}
	  CMAKE_FLAGS "-DINCLUDE_DIRECTORIES:STRING=${CMAKE_CURRENT_SOURCE_DIR}/libarchive"
	  OUTPUT_VARIABLE OUTPUT)

	if(ARCHIVE_CRYPTO_${CRYPTO}_WIN)
	    message(STATUS
	        "Checking support for ARCHIVE_CRYPTO_${CRYPTO}_WIN -- found")
	else(ARCHIVE_CRYPTO_${CRYPTO}_WIN)
	    message(STATUS
	         "Checking support for ARCHIVE_CRYPTO_${CRYPTO}_WIN -- not found")
    	    file(APPEND
	        ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log
                "Checking support for ARCHIVE_CRYPTO_${CRYPTO}_WIN failed with the following output:\n"
        	"${OUTPUT}\n"
        	"Source file was:\n${SOURCE}\n")
	endif(ARCHIVE_CRYPTO_${CRYPTO}_WIN)

      endif(NOT DEFINED ARCHIVE_CRYPTO_${CRYPTO}_WIN)
    endforeach(CRYPTO)
  endif(WIN32 AND NOT CYGWIN)
endmacro(CHECK_CRYPTO_WIN CRYPTO_LIST)

#
# Find iconv
# POSIX defines the second arg as const char **
# and requires it to be in libc.  But we can accept
# a non-const argument here and can support iconv()
# being in libiconv.
#
macro(CHECK_ICONV LIB TRY_ICONV_CONST)
  if(NOT HAVE_ICONV)
    CHECK_C_SOURCE_COMPILES(
      "#include <stdlib.h>
       #include <iconv.h>
       int main() {
          ${TRY_ICONV_CONST} char *ccp;
          iconv_t cd = iconv_open(\"\", \"\");
          iconv(cd, &ccp, (size_t *)0, (char **)0, (size_t *)0);
          iconv_close(cd);
          return 0;
       }"
     HAVE_ICONV_${LIB}_${TRY_ICONV_CONST})
    if(HAVE_ICONV_${LIB}_${TRY_ICONV_CONST})
      set(HAVE_ICONV true)
      set(ICONV_CONST ${TRY_ICONV_CONST})
    endif(HAVE_ICONV_${LIB}_${TRY_ICONV_CONST})
  endif(NOT HAVE_ICONV)
endmacro(CHECK_ICONV TRY_ICONV_CONST)

if(ENABLE_ICONV)
  find_path(ICONV_INCLUDE_DIR iconv.h)
  mark_as_advanced(ICONV_INCLUDE_DIR)
  if(ICONV_INCLUDE_DIR)
    #set(INCLUDES ${INCLUDES} "iconv.h")
    set(HAVE_ICONV_H 1)
    include_directories(${ICONV_INCLUDE_DIR})
    set(CMAKE_REQUIRED_INCLUDES ${ICONV_INCLUDE_DIR})
    CHECK_ICONV("libc" "const")
    CHECK_ICONV("libc" "")

    # If iconv isn't in libc and we have a libiconv, try that.
    find_library(LIBICONV_PATH iconv)
    if(NOT HAVE_ICONV AND LIBICONV_PATH)
      list(APPEND CMAKE_REQUIRED_LIBRARIES ${LIBICONV_PATH})
      CHECK_ICONV("libiconv" "const")
      CHECK_ICONV("libiconv" "")
      if(HAVE_ICONV)
        list(APPEND ADDITIONAL_LIBS ${LIBICONV_PATH})
      endif(HAVE_ICONV)
    endif(NOT HAVE_ICONV AND LIBICONV_PATH)
  endif(ICONV_INCLUDE_DIR)
  #
  # Find locale_charset() for libiconv.
  #
  if(LIBICONV_PATH)
    CHECK_INCLUDE_FILES("localcharset.h" HAVE_LOCALCHARSET_H)
    CHECK_FUNCTION_EXISTS_GLIBC(locale_charset HAVE_LOCALE_CHARSET)
    if(NOT HAVE_LOCALE_CHARSET)
      find_library(LIBCHARSET_PATH charset)
      if(LIBCHARSET_PATH)
        set(CMAKE_REQUIRED_LIBRARIES ${LIBCHARSET_PATH})
        CHECK_FUNCTION_EXISTS_GLIBC(locale_charset HAVE_LOCALE_CHARSET)
        if(HAVE_LOCALE_CHARSET)
          list(APPEND ADDITIONAL_LIBS ${LIBCHARSET_PATH})
        endif(HAVE_LOCALE_CHARSET)
      endif(LIBCHARSET_PATH)
    endif(NOT HAVE_LOCALE_CHARSET)
  endif(LIBICONV_PATH)
else(ENABLE_ICONV)
  # Make sure ICONV variables are not in CACHE after ENABLE_ICONV disabled
  # (once enabled).
  unset(HAVE_LOCALE_CHARSET CACHE)
  unset(HAVE_ICONV CACHE)
  unset(HAVE_ICONV_libc_ CACHE)
  unset(HAVE_ICONV_libc_const CACHE)
  unset(HAVE_ICONV_libiconv_ CACHE)
  unset(HAVE_ICONV_libiconv_const CACHE)
  unset(ICONV_INCLUDE_DIR CACHE)
  unset(LIBICONV_PATH CACHE)
endif(ENABLE_ICONV)

if(0) # CMake does not need XML support in libarchive
#
# Find Libxml2
#
find_package(LibXml2)
if(LIBXML2_FOUND)
  include_directories(${LIBXML2_INCLUDE_DIR})
  list(APPEND ADDITIONAL_LIBS ${LIBXML2_LIBRARIES})
  set(HAVE_LIBXML2 1)
  # libxml2's include files use iconv.h
  set(CMAKE_REQUIRED_INCLUDES ${ICONV_INCLUDE_DIR} ${LIBXML2_INCLUDE_DIR})
  CHECK_INCLUDE_FILES("libxml/xmlreader.h" HAVE_LIBXML_XMLREADER_H)
  CHECK_INCLUDE_FILES("libxml/xmlwriter.h" HAVE_LIBXML_XMLWRITER_H)
  set(CMAKE_REQUIRED_INCLUDES "")
else(LIBXML2_FOUND)
  #
  # Find Expat
  #
  find_package(EXPAT)
  if(EXPAT_FOUND)
    include_directories(${EXPAT_INCLUDE_DIR})
    list(APPEND ADDITIONAL_LIBS ${EXPAT_LIBRARIES})
    set(HAVE_LIBEXPAT 1)
    LA_CHECK_INCLUDE_FILE("expat.h" HAVE_EXPAT_H)
  endif(EXPAT_FOUND)
endif(LIBXML2_FOUND)
endif()

#
# Check functions
#
if("CMAKE_C_COMPILER_ID" MATCHES "^GNU$")
  #
  # During checking functions, we should use -fno-builtin to avoid the
  # failure of function detection which failure is an error "conflicting
  # types for built-in function" caused by using -Werror option.
  #
  set(SAVE_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})
  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -fno-builtin")
endif("CMAKE_C_COMPILER_ID" MATCHES "^GNU$")
CHECK_SYMBOL_EXISTS(_CrtSetReportMode "crtdbg.h" HAVE__CrtSetReportMode)
CHECK_FUNCTION_EXISTS_GLIBC(chflags HAVE_CHFLAGS)
CHECK_FUNCTION_EXISTS_GLIBC(chown HAVE_CHOWN)
CHECK_FUNCTION_EXISTS_GLIBC(chroot HAVE_CHROOT)
CHECK_FUNCTION_EXISTS_GLIBC(ctime_r HAVE_CTIME_R)
CHECK_FUNCTION_EXISTS_GLIBC(fchdir HAVE_FCHDIR)
CHECK_FUNCTION_EXISTS_GLIBC(fchflags HAVE_FCHFLAGS)
CHECK_FUNCTION_EXISTS_GLIBC(fchmod HAVE_FCHMOD)
CHECK_FUNCTION_EXISTS_GLIBC(fchown HAVE_FCHOWN)
CHECK_FUNCTION_EXISTS_GLIBC(fcntl HAVE_FCNTL)
CHECK_FUNCTION_EXISTS_GLIBC(fdopendir HAVE_FDOPENDIR)
CHECK_FUNCTION_EXISTS_GLIBC(fork HAVE_FORK)
CHECK_FUNCTION_EXISTS_GLIBC(fstat HAVE_FSTAT)
CHECK_FUNCTION_EXISTS_GLIBC(fstatat HAVE_FSTATAT)
CHECK_FUNCTION_EXISTS_GLIBC(fstatfs HAVE_FSTATFS)
CHECK_FUNCTION_EXISTS_GLIBC(fstatvfs HAVE_FSTATVFS)
CHECK_FUNCTION_EXISTS_GLIBC(ftruncate HAVE_FTRUNCATE)
CHECK_FUNCTION_EXISTS_GLIBC(futimens HAVE_FUTIMENS)
CHECK_FUNCTION_EXISTS_GLIBC(futimes HAVE_FUTIMES)
CHECK_FUNCTION_EXISTS_GLIBC(futimesat HAVE_FUTIMESAT)
CHECK_FUNCTION_EXISTS_GLIBC(geteuid HAVE_GETEUID)
CHECK_FUNCTION_EXISTS_GLIBC(getgrgid_r HAVE_GETGRGID_R)
CHECK_FUNCTION_EXISTS_GLIBC(getgrnam_r HAVE_GETGRNAM_R)
CHECK_FUNCTION_EXISTS_GLIBC(getpwnam_r HAVE_GETPWNAM_R)
CHECK_FUNCTION_EXISTS_GLIBC(getpwuid_r HAVE_GETPWUID_R)
CHECK_FUNCTION_EXISTS_GLIBC(getpid HAVE_GETPID)
CHECK_FUNCTION_EXISTS_GLIBC(getvfsbyname HAVE_GETVFSBYNAME)
CHECK_FUNCTION_EXISTS_GLIBC(gmtime_r HAVE_GMTIME_R)
CHECK_FUNCTION_EXISTS_GLIBC(lchflags HAVE_LCHFLAGS)
CHECK_FUNCTION_EXISTS_GLIBC(lchmod HAVE_LCHMOD)
CHECK_FUNCTION_EXISTS_GLIBC(lchown HAVE_LCHOWN)
CHECK_FUNCTION_EXISTS_GLIBC(link HAVE_LINK)
CHECK_FUNCTION_EXISTS_GLIBC(localtime_r HAVE_LOCALTIME_R)
CHECK_FUNCTION_EXISTS_GLIBC(lstat HAVE_LSTAT)
CHECK_FUNCTION_EXISTS_GLIBC(lutimes HAVE_LUTIMES)
CHECK_FUNCTION_EXISTS_GLIBC(mbrtowc HAVE_MBRTOWC)
CHECK_FUNCTION_EXISTS_GLIBC(mbsnrtowcs HAVE_MBSNRTOWCS)
CHECK_FUNCTION_EXISTS_GLIBC(memmove HAVE_MEMMOVE)
CHECK_FUNCTION_EXISTS_GLIBC(mkdir HAVE_MKDIR)
CHECK_FUNCTION_EXISTS_GLIBC(mkfifo HAVE_MKFIFO)
CHECK_FUNCTION_EXISTS_GLIBC(mknod HAVE_MKNOD)
CHECK_FUNCTION_EXISTS_GLIBC(mkstemp HAVE_MKSTEMP)
CHECK_FUNCTION_EXISTS_GLIBC(nl_langinfo HAVE_NL_LANGINFO)
CHECK_FUNCTION_EXISTS_GLIBC(openat HAVE_OPENAT)
CHECK_FUNCTION_EXISTS_GLIBC(pipe HAVE_PIPE)
CHECK_FUNCTION_EXISTS_GLIBC(poll HAVE_POLL)
CHECK_FUNCTION_EXISTS_GLIBC(readlink HAVE_READLINK)
CHECK_FUNCTION_EXISTS_GLIBC(select HAVE_SELECT)
CHECK_FUNCTION_EXISTS_GLIBC(setenv HAVE_SETENV)
CHECK_FUNCTION_EXISTS_GLIBC(setlocale HAVE_SETLOCALE)
CHECK_FUNCTION_EXISTS_GLIBC(sigaction HAVE_SIGACTION)
CHECK_FUNCTION_EXISTS_GLIBC(statfs HAVE_STATFS)
CHECK_FUNCTION_EXISTS_GLIBC(statvfs HAVE_STATVFS)
CHECK_FUNCTION_EXISTS_GLIBC(strchr HAVE_STRCHR)
CHECK_FUNCTION_EXISTS_GLIBC(strdup HAVE_STRDUP)
CHECK_FUNCTION_EXISTS_GLIBC(strerror HAVE_STRERROR)
CHECK_FUNCTION_EXISTS_GLIBC(strncpy_s HAVE_STRNCPY_S)
CHECK_FUNCTION_EXISTS_GLIBC(strrchr HAVE_STRRCHR)
CHECK_FUNCTION_EXISTS_GLIBC(symlink HAVE_SYMLINK)
CHECK_FUNCTION_EXISTS_GLIBC(timegm HAVE_TIMEGM)
CHECK_FUNCTION_EXISTS_GLIBC(tzset HAVE_TZSET)
CHECK_FUNCTION_EXISTS_GLIBC(unsetenv HAVE_UNSETENV)
CHECK_FUNCTION_EXISTS_GLIBC(utime HAVE_UTIME)
CHECK_FUNCTION_EXISTS_GLIBC(utimes HAVE_UTIMES)
CHECK_FUNCTION_EXISTS_GLIBC(utimensat HAVE_UTIMENSAT)
CHECK_FUNCTION_EXISTS_GLIBC(vfork HAVE_VFORK)
CHECK_FUNCTION_EXISTS_GLIBC(wcrtomb HAVE_WCRTOMB)
CHECK_FUNCTION_EXISTS_GLIBC(wcscmp HAVE_WCSCMP)
CHECK_FUNCTION_EXISTS_GLIBC(wcscpy HAVE_WCSCPY)
CHECK_FUNCTION_EXISTS_GLIBC(wcslen HAVE_WCSLEN)
CHECK_FUNCTION_EXISTS_GLIBC(wcsnrtombs HAVE_WCSNRTOMBS)
CHECK_FUNCTION_EXISTS_GLIBC(wctomb HAVE_WCTOMB)
CHECK_FUNCTION_EXISTS_GLIBC(_ctime64_s HAVE__CTIME64_S)
CHECK_FUNCTION_EXISTS_GLIBC(_fseeki64 HAVE__FSEEKI64)
CHECK_FUNCTION_EXISTS_GLIBC(_get_timezone HAVE__GET_TIMEZONE)
CHECK_FUNCTION_EXISTS_GLIBC(_localtime64_s HAVE__LOCALTIME64_S)
CHECK_FUNCTION_EXISTS_GLIBC(_mkgmtime64 HAVE__MKGMTIME64)

set(CMAKE_REQUIRED_LIBRARIES "")
CHECK_FUNCTION_EXISTS(cygwin_conv_path HAVE_CYGWIN_CONV_PATH)
CHECK_FUNCTION_EXISTS(fseeko HAVE_FSEEKO)
CHECK_FUNCTION_EXISTS(strerror_r HAVE_STRERROR_R)
CHECK_FUNCTION_EXISTS(strftime HAVE_STRFTIME)
CHECK_FUNCTION_EXISTS(vprintf HAVE_VPRINTF)
CHECK_FUNCTION_EXISTS(wmemcmp HAVE_WMEMCMP)
CHECK_FUNCTION_EXISTS(wmemcpy HAVE_WMEMCPY)

# Restore CMAKE_REQUIRED_FLAGS
if("CMAKE_C_COMPILER_ID" MATCHES "^GNU$")
  set(CMAKE_REQUIRED_FLAGS ${SAVE_CMAKE_REQUIRED_FLAGS})
endif("CMAKE_C_COMPILER_ID" MATCHES "^GNU$")

# Make sure we have the POSIX version of readdir_r, not the
# older 2-argument version.
CHECK_C_SOURCE_COMPILES(
  "#include <dirent.h>\nint main() {DIR *d = opendir(\".\"); struct dirent e,*r; return readdir_r(d,&e,&r);}"
  HAVE_READDIR_R)


# Only detect readlinkat() if we also have AT_FDCWD in unistd.h.
# NOTE: linux requires fcntl.h for AT_FDCWD.
CHECK_C_SOURCE_COMPILES(
  "#include <fcntl.h>\n#include <unistd.h>\nint main() {char buf[10]; return readlinkat(AT_FDCWD, \"\", buf, 0);}"
  HAVE_READLINKAT)


# To verify major(), we need to both include the header
# of interest and verify that the result can be linked.
# CHECK_FUNCTION_EXISTS doesn't accept a header argument,
# CHECK_SYMBOL_EXISTS doesn't test linkage.
CHECK_C_SOURCE_COMPILES(
  "#include <sys/mkdev.h>\nint main() { return major(256); }"
  MAJOR_IN_MKDEV)
CHECK_C_SOURCE_COMPILES(
  "#include <sys/sysmacros.h>\nint main() { return major(256); }"
  MAJOR_IN_SYSMACROS)

if(HAVE_STRERROR_R)
  set(HAVE_DECL_STRERROR_R 1)
endif(HAVE_STRERROR_R)

#
# Check defines
#
set(headers "limits.h")
if(HAVE_STDINT_H)
  list(APPEND headers "stdint.h")
endif(HAVE_STDINT_H)
if(HAVE_INTTYPES_H)
  list(APPEND headers "inttypes.h")
endif(HAVE_INTTYPES_H)
CHECK_SYMBOL_EXISTS(EFTYPE           "errno.h"    HAVE_EFTYPE)
CHECK_SYMBOL_EXISTS(EILSEQ           "errno.h"    HAVE_EILSEQ)
CHECK_SYMBOL_EXISTS(D_MD_ORDER       "langinfo.h" HAVE_D_MD_ORDER)
CHECK_SYMBOL_EXISTS(INT64_MAX        "${headers}" HAVE_DECL_INT64_MAX)
CHECK_SYMBOL_EXISTS(INT64_MIN        "${headers}" HAVE_DECL_INT64_MIN)
CHECK_SYMBOL_EXISTS(UINT32_MAX       "${headers}" HAVE_DECL_UINT32_MAX)
CHECK_SYMBOL_EXISTS(UINT64_MAX       "${headers}" HAVE_DECL_UINT64_MAX)
CHECK_SYMBOL_EXISTS(SIZE_MAX         "${headers}" HAVE_DECL_SIZE_MAX)
CHECK_SYMBOL_EXISTS(SSIZE_MAX        "limits.h"   HAVE_DECL_SSIZE_MAX)

#
# Check struct members
#
# Check for tm_gmtoff in struct tm
CHECK_STRUCT_MEMBER("struct tm" tm_gmtoff
    "time.h" HAVE_STRUCT_TM_TM_GMTOFF)
CHECK_STRUCT_MEMBER("struct tm" __tm_gmtoff
    "time.h" HAVE_STRUCT_TM___TM_GMTOFF)

# Check for f_namemax in struct statfs
CHECK_STRUCT_MEMBER("struct statfs" f_namemax
    "sys/param.h;sys/mount.h" HAVE_STRUCT_STATFS_F_NAMEMAX)

# Check for birthtime in struct stat
CHECK_STRUCT_MEMBER("struct stat" st_birthtime
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_BIRTHTIME)

# Check for high-resolution timestamps in struct stat
CHECK_STRUCT_MEMBER("struct stat" st_birthtimespec.tv_nsec
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC)
CHECK_STRUCT_MEMBER("struct stat" st_mtimespec.tv_nsec
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC)
CHECK_STRUCT_MEMBER("struct stat" st_mtim.tv_nsec
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)
CHECK_STRUCT_MEMBER("struct stat" st_mtime_n
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_MTIME_N)
CHECK_STRUCT_MEMBER("struct stat" st_umtime
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_UMTIME)
CHECK_STRUCT_MEMBER("struct stat" st_mtime_usec
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_MTIME_USEC)
# Check for block size support in struct stat
CHECK_STRUCT_MEMBER("struct stat" st_blksize
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_BLKSIZE)
# Check for st_flags in struct stat (BSD fflags)
CHECK_STRUCT_MEMBER("struct stat" st_flags
    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_FLAGS)

if(HAVE_SYS_STATVFS_H)
  CHECK_STRUCT_MEMBER("struct statvfs" f_iosize
    "sys/types.h;sys/statvfs.h" HAVE_STRUCT_STATVFS_F_IOSIZE)
endif()

#
#
CHECK_STRUCT_MEMBER("struct tm" tm_sec
    "sys/types.h;sys/time.h;time.h" TIME_WITH_SYS_TIME)

#
# Check for integer types
#
#
CHECK_TYPE_SIZE("short" SIZE_OF_SHORT)
CHECK_TYPE_SIZE("int" SIZE_OF_INT)
CHECK_TYPE_SIZE("long" SIZE_OF_LONG)
CHECK_TYPE_SIZE("long long"     SIZE_OF_LONG_LONG)

CHECK_TYPE_SIZE("unsigned short" SIZE_OF_UNSIGNED_SHORT)
CHECK_TYPE_SIZE("unsigned" SIZE_OF_UNSIGNED)
CHECK_TYPE_SIZE("unsigned long" SIZE_OF_UNSIGNED_LONG)
CHECK_TYPE_SIZE("unsigned long long" SIZE_OF_UNSIGNED_LONG_LONG)

CHECK_TYPE_SIZE("__int64" __INT64)
CHECK_TYPE_SIZE("unsigned __int64" UNSIGNED___INT64)

CHECK_TYPE_SIZE(int16_t INT16_T)
CHECK_TYPE_SIZE(int32_t INT32_T)
CHECK_TYPE_SIZE(int64_t INT64_T)
CHECK_TYPE_SIZE(intmax_t INTMAX_T)
CHECK_TYPE_SIZE(uint8_t UINT8_T)
CHECK_TYPE_SIZE(uint16_t UINT16_T)
CHECK_TYPE_SIZE(uint32_t UINT32_T)
CHECK_TYPE_SIZE(uint64_t UINT64_T)
CHECK_TYPE_SIZE(uintmax_t UINTMAX_T)

CHECK_TYPE_SIZE(dev_t       DEV_T)
if(NOT HAVE_DEV_T)
  if(MSVC)
    set(dev_t "unsigned int")
  endif(MSVC)
endif(NOT HAVE_DEV_T)
#
CHECK_TYPE_SIZE(gid_t       GID_T)
if(NOT HAVE_GID_T)
  if(WIN32)
    set(gid_t "short")
  else(WIN32)
    set(gid_t "unsigned int")
  endif(WIN32)
endif(NOT HAVE_GID_T)
#
CHECK_TYPE_SIZE(id_t        ID_T)
if(NOT HAVE_ID_T)
  if(WIN32)
    set(id_t "short")
  else(WIN32)
    set(id_t "unsigned int")
  endif(WIN32)
endif(NOT HAVE_ID_T)
#
CHECK_TYPE_SIZE(mode_t      MODE_T)
if(NOT HAVE_MODE_T)
  if(WIN32)
    set(mode_t "unsigned short")
  else(WIN32)
    set(mode_t "int")
  endif(WIN32)
endif(NOT HAVE_MODE_T)
#
CHECK_TYPE_SIZE(off_t       OFF_T)
if(NOT HAVE_OFF_T)
  set(off_t "__int64")
endif(NOT HAVE_OFF_T)
#
CHECK_TYPE_SIZE(size_t      SIZE_T)
if(NOT HAVE_SIZE_T)
  if("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
    set(size_t "uint64_t")
  else("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
    set(size_t   "uint32_t")
  endif("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
endif(NOT HAVE_SIZE_T)
#
CHECK_TYPE_SIZE(ssize_t     SSIZE_T)
if(NOT HAVE_SSIZE_T)
  if("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
    set(ssize_t "int64_t")
  else("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
    set(ssize_t "long")
  endif("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
endif(NOT HAVE_SSIZE_T)
#
CHECK_TYPE_SIZE(uid_t       UID_T)
if(NOT HAVE_UID_T)
  if(WIN32)
    set(uid_t "short")
  else(WIN32)
    set(uid_t "unsigned int")
  endif(WIN32)
endif(NOT HAVE_UID_T)
#
CHECK_TYPE_SIZE(pid_t       PID_T)
if(NOT HAVE_PID_T)
  if(WIN32)
    set(pid_t "int")
  else(WIN32)
    message(FATAL_ERROR "pid_t doesn't exist on this platform?")
  endif(WIN32)
endif(NOT HAVE_PID_T)
#
CHECK_TYPE_SIZE(intptr_t   INTPTR_T)
if(NOT HAVE_INTPTR_T)
  if("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
    set(intptr_t "int64_t")
  else()
    set(intptr_t "int32_t")
  endif()
endif(NOT HAVE_INTPTR_T)
#
CHECK_TYPE_SIZE(uintptr_t   UINTPTR_T)
if(NOT HAVE_UINTPTR_T)
  if("${CMAKE_SIZEOF_VOID_P}" EQUAL 8)
    set(uintptr_t "uint64_t")
  else()
    set(uintptr_t "uint32_t")
  endif()
endif(NOT HAVE_UINTPTR_T)
#
CHECK_TYPE_SIZE(wchar_t     SIZEOF_WCHAR_T)
if(HAVE_SIZEOF_WCHAR_T)
  set(HAVE_WCHAR_T 1)
endif(HAVE_SIZEOF_WCHAR_T)
#
# Check if _FILE_OFFSET_BITS macro needed for large files
#
CHECK_FILE_OFFSET_BITS()

#
# Check for Extended Attribute libraries, headers, and functions
#
if(ENABLE_XATTR)
  LA_CHECK_INCLUDE_FILE(attr/xattr.h     HAVE_ATTR_XATTR_H)
  LA_CHECK_INCLUDE_FILE(sys/xattr.h      HAVE_SYS_XATTR_H)
  LA_CHECK_INCLUDE_FILE(sys/extattr.h      HAVE_SYS_EXTATTR_H)
  CHECK_LIBRARY_EXISTS(attr "setxattr" "" HAVE_LIBATTR)
  if(HAVE_LIBATTR)
    set(CMAKE_REQUIRED_LIBRARIES "attr")
  endif(HAVE_LIBATTR)
  CHECK_SYMBOL_EXISTS(EXTATTR_NAMESPACE_USER "sys/types.h;sys/extattr.h" HAVE_DECL_EXTATTR_NAMESPACE_USER)
  CHECK_FUNCTION_EXISTS_GLIBC(extattr_get_file HAVE_EXTATTR_GET_FILE)
  CHECK_FUNCTION_EXISTS_GLIBC(extattr_list_file HAVE_EXTATTR_LIST_FILE)
  CHECK_FUNCTION_EXISTS_GLIBC(extattr_set_fd HAVE_EXTATTR_SET_FD)
  CHECK_FUNCTION_EXISTS_GLIBC(extattr_set_file HAVE_EXTATTR_SET_FILE)
  CHECK_FUNCTION_EXISTS_GLIBC(fgetxattr HAVE_FGETXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(flistxattr HAVE_FLISTXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(fsetxattr HAVE_FSETXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(getxattr HAVE_GETXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(lgetxattr HAVE_LGETXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(listxattr HAVE_LISTXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(llistxattr HAVE_LLISTXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(lsetxattr HAVE_LSETXATTR)
  CHECK_FUNCTION_EXISTS_GLIBC(fgetea HAVE_FGETEA)
  CHECK_FUNCTION_EXISTS_GLIBC(flistea HAVE_FLISTEA)
  CHECK_FUNCTION_EXISTS_GLIBC(fsetea HAVE_FSETEA)
  CHECK_FUNCTION_EXISTS_GLIBC(getea HAVE_GETEA)
  CHECK_FUNCTION_EXISTS_GLIBC(lgetea HAVE_LGETEA)
  CHECK_FUNCTION_EXISTS_GLIBC(listea HAVE_LISTEA)
  CHECK_FUNCTION_EXISTS_GLIBC(llistea HAVE_LLISTEA)
  CHECK_FUNCTION_EXISTS_GLIBC(lsetea HAVE_LSETEA)
else(ENABLE_XATTR)
  set(HAVE_ATTR_LIB FALSE)
  set(HAVE_ATTR_XATTR_H FALSE)
  set(HAVE_DECL_EXTATTR_NAMESPACE_USER FALSE)
  set(HAVE_EXTATTR_GET_FILE FALSE)
  set(HAVE_EXTATTR_LIST_FILE FALSE)
  set(HAVE_EXTATTR_SET_FD FALSE)
  set(HAVE_EXTATTR_SET_FILE FALSE)
  set(HAVE_FGETEA FALSE)
  set(HAVE_FGETXATTR FALSE)
  set(HAVE_FLISTEA FALSE)
  set(HAVE_FLISTXATTR FALSE)
  set(HAVE_FSETEA FALSE)
  set(HAVE_FSETXATTR FALSE)
  set(HAVE_GETEA FALSE)
  set(HAVE_GETXATTR FALSE)
  set(HAVE_LGETEA FALSE)
  set(HAVE_LGETXATTR FALSE)
  set(HAVE_LISTEA FALSE)
  set(HAVE_LISTXATTR FALSE)
  set(HAVE_LLISTEA FALSE)
  set(HAVE_LLISTXATTR FALSE)
  set(HAVE_LSETEA FALSE)
  set(HAVE_LSETXATTR FALSE)
  set(HAVE_SYS_EXTATTR_H FALSE)
  set(HAVE_SYS_XATTR_H FALSE)
endif(ENABLE_XATTR)

#
# Check for ACL libraries, headers, and functions
#
# The ACL support in libarchive is written against the POSIX1e draft,
# which was never officially approved and varies quite a bit across
# platforms.  Worse, some systems have completely non-POSIX acl functions,
# which makes the following checks rather more complex than I would like.
#
if(ENABLE_ACL)
  CHECK_LIBRARY_EXISTS(acl "acl_get_file" "" HAVE_LIBACL)
  if(HAVE_LIBACL)
    set(CMAKE_REQUIRED_LIBRARIES "acl")
    find_library(ACL_LIBRARY NAMES acl)
    list(APPEND ADDITIONAL_LIBS ${ACL_LIBRARY})
  endif(HAVE_LIBACL)
  #
  CHECK_FUNCTION_EXISTS_GLIBC(acl_create_entry HAVE_ACL_CREATE_ENTRY)
  CHECK_FUNCTION_EXISTS_GLIBC(acl_init HAVE_ACL_INIT)
  CHECK_FUNCTION_EXISTS_GLIBC(acl_set_fd HAVE_ACL_SET_FD)
  CHECK_FUNCTION_EXISTS_GLIBC(acl_set_fd_np HAVE_ACL_SET_FD_NP)
  CHECK_FUNCTION_EXISTS_GLIBC(acl_set_file HAVE_ACL_SET_FILE)
  CHECK_TYPE_EXISTS(acl_permset_t "${INCLUDES}"    HAVE_ACL_PERMSET_T)

  # The "acl_get_perm()" function was omitted from the POSIX draft.
  # (It's a pretty obvious oversight; otherwise, there's no way to
  # test for specific permissions in a permset.)  Linux uses the obvious
  # name, FreeBSD adds _np to mark it as "non-Posix extension."
  # Test for both as a double-check that we really have POSIX-style ACL support.
  CHECK_FUNCTION_EXISTS(acl_get_perm HAVE_ACL_GET_PERM)
  CHECK_FUNCTION_EXISTS(acl_get_perm_np HAVE_ACL_GET_PERM_NP)
  CHECK_FUNCTION_EXISTS(acl_get_link HAVE_ACL_GET_LINK)
  CHECK_FUNCTION_EXISTS(acl_get_link_np HAVE_ACL_GET_LINK_NP)

  # MacOS has an acl.h that isn't POSIX.  It can be detected by
  # checking for ACL_USER
  CHECK_SYMBOL_EXISTS(ACL_USER "${INCLUDES}" HAVE_ACL_USER)
else(ENABLE_ACL)
  # If someone runs cmake, then disables ACL support, we need
  # to forcibly override the cached values for these.
  set(HAVE_ACL_CREATE_ENTRY FALSE)
  set(HAVE_ACL_GET_LINK FALSE)
  set(HAVE_ACL_GET_LINK_NP FALSE)
  set(HAVE_ACL_GET_PERM FALSE)
  set(HAVE_ACL_GET_PERM_NP FALSE)
  set(HAVE_ACL_INIT FALSE)
  set(HAVE_ACL_LIB FALSE)
  set(HAVE_ACL_PERMSET_T FALSE)
  set(HAVE_ACL_SET_FD FALSE)
  set(HAVE_ACL_SET_FD_NP FALSE)
  set(HAVE_ACL_SET_FILE FALSE)
  set(HAVE_ACL_USER FALSE)
endif(ENABLE_ACL)

#
# Check MD5/RMD160/SHA support
# NOTE: Crypto checks must be run last before generating config.h
#
CHECK_CRYPTO("MD5;RMD160;SHA1;SHA256;SHA384;SHA512" LIBC)
CHECK_CRYPTO("SHA256;SHA384;SHA512" LIBC2)
CHECK_CRYPTO("SHA256;SHA384;SHA512" LIBC3)
CHECK_CRYPTO("MD5;SHA1;SHA256;SHA384;SHA512" LIBSYSTEM)
CHECK_CRYPTO("MD5;RMD160;SHA1;SHA256;SHA384;SHA512" NETTLE)
CHECK_CRYPTO("MD5;RMD160;SHA1;SHA256;SHA384;SHA512" OPENSSL)

# Libmd has to be probed after OpenSSL.
CHECK_CRYPTO("MD5;RMD160;SHA1;SHA256;SHA512" LIBMD)

CHECK_CRYPTO_WIN("MD5;SHA1;SHA256;SHA384;SHA512")

# Generate "config.h" from "build/cmake/config.h.in"
configure_file(${CMAKE_CURRENT_SOURCE_DIR}/build/cmake/config.h.in
	${CMAKE_CURRENT_BINARY_DIR}/config.h)
include_directories(BEFORE ${CMAKE_CURRENT_BINARY_DIR})
add_definitions(-DHAVE_CONFIG_H)

#
# Register installation of PDF documents.
#
if(WIN32 AND NOT CYGWIN)
  #
  # On Windows platform, It's better that we install PDF documents
  # on one's computer.
  # These PDF documents are available in the release package.
  #
  if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/doc/pdf)
    install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/doc/pdf
            DESTINATION share/man
            FILES_MATCHING PATTERN "*.pdf"
    )
  endif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/doc/pdf)
endif(WIN32 AND NOT CYGWIN)
#
#
#
include_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR}/libarchive)
#
if(MSVC)
  add_definitions(-D_CRT_SECURE_NO_DEPRECATE)
endif(MSVC)

# We need CoreServices on Mac OS.
if(APPLE)
  list(APPEND ADDITIONAL_LIBS "-framework CoreServices")
endif(APPLE)

add_subdirectory(libarchive)

install(FILES COPYING DESTINATION ${CMake_DOC_DEST}/cmlibarchive)
