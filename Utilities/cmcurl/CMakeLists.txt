CMAKE_MINIMUM_REQUIRED(VERSION 2.6.3 FATAL_ERROR)
IF(POLICY CMP0025)
  CMAKE_POLICY(SET CMP0025 NEW)
ENDIF()
PROJECT(LIBCURL C)

# Setup package meta-data
SET(PACKAGE "curl")
SET(VERSION "7.16.1")
SET(PACKAGE_TARNAME "curl")
SET(PACKAGE_BUGREPORT " ")
SET(PACKAGE_NAME "curl")
SET(PACKAGE_VERSION "-")
SET(PACKAGE_STRING "curl-")
SET(PACKAGE_BUGREPORT "a suitable curl mailing list => http://curl.haxx.se/mail/")
SET(OPERATING_SYSTEM "${CMAKE_SYSTEM_NAME}")

# We need ansi c-flags, especially on HP
SET(CMAKE_C_FLAGS "${CMAKE_ANSI_CFLAGS} ${CMAKE_C_FLAGS}")
SET(CMAKE_REQUIRED_FLAGS ${CMAKE_ANSI_CFLAGS})

# Disable warnings on Borland to avoid changing 3rd party code.
IF(BORLAND)
  SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -w-")
ENDIF(BORLAND)

# If we are on AIX, do the _ALL_SOURCE magic
IF(${CMAKE_SYSTEM_NAME} MATCHES AIX)
  SET(_ALL_SOURCE 1)
ENDIF(${CMAKE_SYSTEM_NAME} MATCHES AIX)

# Include all the necessary files for macros
SET(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake")
INCLUDE (CheckFunctionExists)
INCLUDE (CheckIncludeFile)
INCLUDE (CheckIncludeFiles)
INCLUDE (CheckLibraryExists)
INCLUDE (CheckSymbolExists)
INCLUDE (CheckTypeSize)

SET(libCurl_SRCS
  #  amigaos.c - does not build on AmigaOS
  base64.c
  connect.c
  content_encoding.c
  cookie.c
  dict.c
  easy.c
  escape.c
  file.c
  formdata.c
  ftp.c
  getenv.c
  getinfo.c
  gtls.c
  hash.c
  hostares.c
  hostasyn.c
  hostip4.c
  hostip6.c
  hostip.c
  hostsyn.c
  hostthre.c
  http.c
  http_chunks.c
  http_digest.c
  http_negotiate.c
  http_ntlm.c
  if2ip.c
  inet_ntop.c
  inet_pton.c
  krb4.c
  ldap.c
  llist.c
  md5.c
#  memdebug.c -not used
  mprintf.c
  multi.c
  netrc.c
  # nwlib.c - Not used
  parsedate.c
  progress.c
  security.c
  select.c
  sendf.c
  share.c
  socks.c
  speedcheck.c
  splay.c
  ssh.c
  sslgen.c
  ssluse.c
  strdup.c
  strequal.c
  strerror.c
  # strtok.c - specify later
  # strtoofft.c - specify later
  telnet.c
  tftp.c
  timeval.c
  transfer.c
  url.c
  version.c
  )

SET(CURL_DISABLE_LDAP 1)
IF(NOT CURL_DISABLE_LDAP)
  SET(libCurl_SRCS
    ${libCurl_SRCS}
    ldap.c
    )
ENDIF(NOT CURL_DISABLE_LDAP)

# if we have Kerberos 4, right now this is never on
#OPTION(CURL_KRB4 "Use Kerberos 4" OFF)
IF(CURL_KRB4)
  SET(libCurl_SRCS ${libCurl_SRCS}
    krb4.c
    security.c
    )
ENDIF(CURL_KRB4)

#OPTION(CURL_MALLOC_DEBUG "Debug mallocs in Curl" OFF)
MARK_AS_ADVANCED(CURL_MALLOC_DEBUG)
IF(CURL_MALLOC_DEBUG)
  SET(libCurl_SRCS ${libCurl_SRCS}
    memdebug.c
    )
ENDIF(CURL_MALLOC_DEBUG)

# On windows preload settings
IF(WIN32 AND NOT MINGW)
  INCLUDE(${LIBCURL_SOURCE_DIR}/Platforms/WindowsCache.cmake)
ENDIF()

# This macro checks if the symbol exists in the library and if it
# does, it appends library to the list.
SET(CURL_LIBS "")
MACRO(CHECK_LIBRARY_EXISTS_CONCAT LIBRARY SYMBOL VARIABLE)
  CHECK_LIBRARY_EXISTS("${LIBRARY};${CURL_LIBS}" ${SYMBOL} ""
    ${VARIABLE})
  IF(${VARIABLE})
    SET(CURL_LIBS ${CURL_LIBS} ${LIBRARY})
  ENDIF(${VARIABLE})
ENDMACRO(CHECK_LIBRARY_EXISTS_CONCAT)

# Check for all needed libraries
# use the cmake defined dl libs as dl is should not be used
# on HPUX, but rather dld this avoids a warning
SET(CURL_LIBS ${CURL_LIBS} ${CMAKE_DL_LIBS})
#CHECK_LIBRARY_EXISTS_CONCAT("dl"     dlopen       HAVE_LIBDL)
#CHECK_LIBRARY_EXISTS_CONCAT("ucb"    gethostname  HAVE_LIBUCB)
CHECK_LIBRARY_EXISTS_CONCAT("socket" connect      HAVE_LIBSOCKET)
CHECK_LIBRARY_EXISTS("c" gethostbyname "" NOT_NEED_LIBNSL)

# Yellowtab Zeta needs different libraries than BeOS 5.
IF(BEOS)
  SET(NOT_NEED_LIBNSL 1)
  CHECK_LIBRARY_EXISTS_CONCAT("bind" gethostbyname HAVE_LIBBIND)
  CHECK_LIBRARY_EXISTS_CONCAT("bnetapi" closesocket HAVE_LIBBNETAPI)
ENDIF(BEOS)

CHECK_LIBRARY_EXISTS_CONCAT("network" recv HAVE_LIBNETWORK)

IF(NOT NOT_NEED_LIBNSL)
  CHECK_LIBRARY_EXISTS_CONCAT("nsl"    gethostbyname  HAVE_LIBNSL)
ENDIF(NOT NOT_NEED_LIBNSL)

CHECK_LIBRARY_EXISTS_CONCAT("ws2_32" getch        HAVE_LIBWS2_32)
CHECK_LIBRARY_EXISTS_CONCAT("winmm"  getch        HAVE_LIBWINMM)
IF(NOT CURL_SPECIAL_LIBZ)
  CHECK_LIBRARY_EXISTS_CONCAT("z"      inflateEnd   HAVE_LIBZ)
ENDIF(NOT CURL_SPECIAL_LIBZ)

# Include the local directories before any others so that we do not end up
# including system curl's include directory first by mistake.
INCLUDE_DIRECTORIES(${LIBCURL_SOURCE_DIR})
INCLUDE_DIRECTORIES(${LIBCURL_BINARY_DIR})

OPTION(CMAKE_USE_OPENSSL "Use OpenSSL code with curl." OFF)
MARK_AS_ADVANCED(CMAKE_USE_OPENSSL)
IF(CMAKE_USE_OPENSSL)
  SET(USE_SSLEAY TRUE)
  SET(USE_OPENSSL TRUE)
  FIND_PACKAGE(OpenSSL REQUIRED)
  INCLUDE_DIRECTORIES(${OPENSSL_INCLUDE_DIR})
  SET(CURL_LIBS  ${CURL_LIBS} ${OPENSSL_LIBRARIES})
  SET(CURL_CA_BUNDLE "" CACHE FILEPATH "Path to SSL CA Certificate Bundle")
  MARK_AS_ADVANCED(CURL_CA_BUNDLE)
  IF(CURL_CA_BUNDLE)
    ADD_DEFINITIONS(-DCURL_CA_BUNDLE="${CURL_CA_BUNDLE}")
  ENDIF(CURL_CA_BUNDLE)
  # for windows we want to install OPENSSL_LIBRARIES dlls
  # and also copy them into the build tree so that testing
  # can find them.
  IF(WIN32)
    FIND_FILE(CMAKE_EAY_DLL NAME libeay32.dll HINTS ${OPENSSL_INCLUDE_DIR}/..)
    FIND_FILE(CMAKE_SSL_DLL NAME ssleay32.dll HINTS ${OPENSSL_INCLUDE_DIR}/..)
    MARK_AS_ADVANCED(CMAKE_EAY_DLL CMAKE_SSL_DLL)
    IF(CMAKE_SSL_DLL AND CMAKE_EAY_DLL)
      SET(CMAKE_CURL_SSL_DLLS ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/libeay32.dll
        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/ssleay32.dll)
      ADD_CUSTOM_COMMAND(OUTPUT
        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/libeay32.dll
        DEPENDS ${CMAKE_EAY_DLL}
        COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_EAY_DLL}
        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/libeay32.dll)
      ADD_CUSTOM_COMMAND(OUTPUT
        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/ssleay32.dll
        DEPENDS ${CMAKE_SSL_DLL}
        COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_SSL_DLL}
        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/ssleay32.dll)
      INSTALL(PROGRAMS ${CMAKE_EAY_DLL} ${CMAKE_SSL_DLL} DESTINATION bin)
    ENDIF()
  ENDIF()
ENDIF(CMAKE_USE_OPENSSL)

# Check for idn
CHECK_LIBRARY_EXISTS_CONCAT("idn" idna_to_ascii_lz HAVE_LIBIDN)

# Check for symbol dlopen (same as HAVE_LIBDL)
CHECK_LIBRARY_EXISTS("${CURL_LIBS}" dlopen "" HAVE_DLOPEN)

# For other tests to use the same libraries
SET(CMAKE_REQUIRED_LIBRARIES ${CURL_LIBS})

IF(CURL_SPECIAL_LIBZ)
  SET(CURL_LIBS ${CURL_LIBS} "${CURL_SPECIAL_LIBZ}")
  INCLUDE_DIRECTORIES(${CURL_SPECIAL_LIBZ_INCLUDES})
  SET(HAVE_LIBZ 0)
  SET(HAVE_ZLIB_H 0)
ENDIF(CURL_SPECIAL_LIBZ)

# do we have process.h
CHECK_INCLUDE_FILE("process.h" HAVE_PROCESS_H)

# If we have features.h, then do the _BSD_SOURCE magic
CHECK_INCLUDE_FILE("features.h"       HAVE_FEATURES_H)
IF(HAVE_FEATURES_H)
  SET_SOURCE_FILES_PROPERTIES(
    cookie.c
    easy.c
    formdata.c
    getenv.c
    hash.c
    http.c
    if2ip.c
    mprintf.c
    multi.c
    sendf.c
    telnet.c
    transfer.c
    url.c
    COMPILE_FLAGS -D_BSD_SOURCE)
ENDIF(HAVE_FEATURES_H)

# Check if header file exists and add it to the list.
MACRO(CHECK_INCLUDE_FILE_CONCAT FILE VARIABLE)
  CHECK_INCLUDE_FILES("${CURL_INCLUDES};${FILE}" ${VARIABLE})
  IF(${VARIABLE})
    SET(CURL_INCLUDES ${CURL_INCLUDES} ${FILE})
  ENDIF(${VARIABLE})
ENDMACRO(CHECK_INCLUDE_FILE_CONCAT)

# Check for header files
IF(UNIX)
  SET(HAVE_WINDOWS_H 0)
  SET(HAVE_WINSOCK_H 0)
  SET(HAVE_WS2TCPIP_H 0)
  SET(HAVE_WINSOCK2_H 0)
ENDIF(UNIX)
IF(NOT UNIX)
  CHECK_INCLUDE_FILE_CONCAT("ws2tcpip.h"     HAVE_WS2TCPIP_H)
  CHECK_INCLUDE_FILE_CONCAT("winsock2.h"     HAVE_WINSOCK2_H)
ENDIF(NOT UNIX)
CHECK_INCLUDE_FILE_CONCAT("stdio.h"          HAVE_STDIO_H)
IF(NOT UNIX)
  CHECK_INCLUDE_FILE_CONCAT("windows.h"      HAVE_WINDOWS_H)
  CHECK_INCLUDE_FILE_CONCAT("winsock.h"      HAVE_WINSOCK_H)
ENDIF(NOT UNIX)
CHECK_INCLUDE_FILE_CONCAT("stddef.h"         HAVE_STDDEF_H)
CHECK_INCLUDE_FILE_CONCAT("sys/types.h"      HAVE_SYS_TYPES_H)
CHECK_INCLUDE_FILE_CONCAT("inttypes.h"       HAVE_INTTYPES_H)
CHECK_INCLUDE_FILE_CONCAT("alloca.h"         HAVE_ALLOCA_H)
CHECK_INCLUDE_FILE_CONCAT("arpa/inet.h"      HAVE_ARPA_INET_H)
CHECK_INCLUDE_FILE_CONCAT("dlfcn.h"          HAVE_DLFCN_H)
CHECK_INCLUDE_FILE_CONCAT("fcntl.h"          HAVE_FCNTL_H)
CHECK_INCLUDE_FILE_CONCAT("malloc.h"         HAVE_MALLOC_H)
CHECK_INCLUDE_FILE_CONCAT("memory.h"         HAVE_MEMORY_H)
CHECK_INCLUDE_FILE_CONCAT("netdb.h"          HAVE_NETDB_H)
CHECK_INCLUDE_FILE_CONCAT("sys/poll.h"       HAVE_SYS_POLL_H)
CHECK_INCLUDE_FILE_CONCAT("assert.h"         HAVE_ASSERT_H)
CHECK_INCLUDE_FILE_CONCAT("limits.h"         HAVE_LIMITS_H)

IF(CMAKE_USE_OPENSSL)
  CHECK_INCLUDE_FILE_CONCAT("openssl/x509.h"   HAVE_OPENSSL_X509_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/engine.h" HAVE_OPENSSL_ENGINE_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/rsa.h"    HAVE_OPENSSL_RSA_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/crypto.h" HAVE_OPENSSL_CRYPTO_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/pem.h"    HAVE_OPENSSL_PEM_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/ssl.h"    HAVE_OPENSSL_SSL_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/err.h"    HAVE_OPENSSL_ERR_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/rand.h"   HAVE_OPENSSL_RAND_H)
  CHECK_INCLUDE_FILE_CONCAT("openssl/pkcs12.h" HAVE_OPENSSL_PKCS12_H)
ENDIF(CMAKE_USE_OPENSSL)

IF(NOT CURL_SPECIAL_LIBZ)
  CHECK_INCLUDE_FILE_CONCAT("zlib.h"           HAVE_ZLIB_H)
ENDIF(NOT CURL_SPECIAL_LIBZ)
CHECK_INCLUDE_FILE_CONCAT("sys/socket.h"     HAVE_SYS_SOCKET_H)
CHECK_INCLUDE_FILE_CONCAT("netinet/in.h"     HAVE_NETINET_IN_H)
CHECK_INCLUDE_FILE_CONCAT("net/if.h"         HAVE_NET_IF_H)
CHECK_INCLUDE_FILE_CONCAT("netinet/if_ether.h"
  HAVE_NETINET_IF_ETHER_H)
CHECK_INCLUDE_FILE_CONCAT("netinet/tcp.h"
  HAVE_NETINET_TCP_H)
CHECK_INCLUDE_FILE_CONCAT("sys/select.h"    HAVE_SYS_SELECT_H)
CHECK_INCLUDE_FILE_CONCAT("utime.h"         HAVE_UTIME_H)
CHECK_INCLUDE_FILE_CONCAT("netinet/in.h"    HAVE_NETINET_IN_H)
CHECK_INCLUDE_FILE_CONCAT("pwd.h"           HAVE_PWD_H)
CHECK_INCLUDE_FILE_CONCAT("sgtty.h"         HAVE_SGTTY_H)
CHECK_INCLUDE_FILE_CONCAT("stdint.h"        HAVE_STDINT_H)
CHECK_INCLUDE_FILE_CONCAT("stdlib.h"        HAVE_STDLIB_H)
CHECK_INCLUDE_FILE_CONCAT("string.h"        HAVE_STRING_H)
CHECK_INCLUDE_FILE_CONCAT("strings.h"       HAVE_STRINGS_H)
CHECK_INCLUDE_FILE_CONCAT("sys/param.h"     HAVE_SYS_PARAM_H)
CHECK_INCLUDE_FILE_CONCAT("sys/stat.h"      HAVE_SYS_STAT_H)
CHECK_INCLUDE_FILE_CONCAT("sys/time.h"      HAVE_SYS_TIME_H)
CHECK_INCLUDE_FILE_CONCAT("sys/resource.h"  HAVE_SYS_RESOURCE_H)
CHECK_INCLUDE_FILE_CONCAT("termios.h"       HAVE_TERMIOS_H)
CHECK_INCLUDE_FILE_CONCAT("termio.h"        HAVE_TERMIO_H)
CHECK_INCLUDE_FILE_CONCAT("io.h"            HAVE_IO_H)
CHECK_INCLUDE_FILE_CONCAT("time.h"          HAVE_TIME_H)
CHECK_INCLUDE_FILE_CONCAT("unistd.h"        HAVE_UNISTD_H)
CHECK_INCLUDE_FILE_CONCAT("sys/utime.h"     HAVE_SYS_UTIME_H)
CHECK_INCLUDE_FILE_CONCAT("sockio.h"        HAVE_SOCKIO_H)
CHECK_INCLUDE_FILE_CONCAT("sys/sockio.h"    HAVE_SYS_SOCKIO_H)
CHECK_INCLUDE_FILE_CONCAT("x509.h"          HAVE_X509_H)
CHECK_INCLUDE_FILE_CONCAT("locale.h"        HAVE_LOCALE_H)
CHECK_INCLUDE_FILE_CONCAT("setjmp.h"        HAVE_SETJMP_H)
CHECK_INCLUDE_FILE_CONCAT("signal.h"        HAVE_SIGNAL_H)
CHECK_INCLUDE_FILE_CONCAT("sys/ioctl.h"     HAVE_SYS_IOCTL_H)
CHECK_INCLUDE_FILE_CONCAT("sys/utsname.h"   HAVE_SYS_UTSNAME_H)
CHECK_INCLUDE_FILE_CONCAT("idn-free.h"      HAVE_IDN_FREE_H)
CHECK_INCLUDE_FILE_CONCAT("idna.h"          HAVE_IDNA_H)
CHECK_INCLUDE_FILE_CONCAT("tld.h"           HAVE_TLD_H)
CHECK_INCLUDE_FILE_CONCAT("arpa/tftp.h"     HAVE_ARPA_TFTP_H)
CHECK_INCLUDE_FILE_CONCAT("errno.h"         HAVE_ERRNO_H)
CHECK_INCLUDE_FILE_CONCAT("libgen.h"        HAVE_LIBGEN_H)
CHECK_INCLUDE_FILE_CONCAT("sys/filio.h"     HAVE_SYS_FILIO_H)
CHECK_TYPE_SIZE(size_t  SIZEOF_SIZE_T)
CHECK_TYPE_SIZE(ssize_t  SIZEOF_SSIZE_T)
CHECK_TYPE_SIZE("long long"  SIZEOF_LONG_LONG)
CHECK_TYPE_SIZE("long"  SIZEOF_LONG)
CHECK_TYPE_SIZE("__int64"  SIZEOF___INT64)
CHECK_TYPE_SIZE("time_t"  SIZEOF_TIME_T)

IF(HAVE_SIZEOF_LONG_LONG)
  SET(HAVE_LONGLONG 1)
  SET(HAVE_LL 1)
ENDIF(HAVE_SIZEOF_LONG_LONG)

FIND_FILE(RANDOM_FILE urandom /dev)
MARK_AS_ADVANCED(RANDOM_FILE)

#strtoll \
#socket \
#select \
#strdup \
#strstr \
#strtok_r \
#uname \
#strcasecmp \
#stricmp \
#strcmpi \
#gethostbyaddr \
#gettimeofday \
#inet_addr \
#inet_ntoa \
#inet_pton \
#perror \
#closesocket \
#siginterrupt \
#sigaction \
#signal \
#getpass_r \
#getpwuid \
#geteuid \
#dlopen \
#utime \
#sigsetjmp \
#basename \
#setlocale \
#ftruncate \
#pipe \
#poll \
#getprotobyname \
#getrlimit \
#setrlimit \
#fork

# Check for some functions that are used
CHECK_SYMBOL_EXISTS(basename      "${CURL_INCLUDES}" HAVE_BASENAME)
CHECK_SYMBOL_EXISTS(socket        "${CURL_INCLUDES}" HAVE_SOCKET)
CHECK_SYMBOL_EXISTS(poll          "${CURL_INCLUDES}" HAVE_POLL)
CHECK_SYMBOL_EXISTS(select        "${CURL_INCLUDES}" HAVE_SELECT)
CHECK_SYMBOL_EXISTS(strdup        "${CURL_INCLUDES}" HAVE_STRDUP)
CHECK_SYMBOL_EXISTS(strstr        "${CURL_INCLUDES}" HAVE_STRSTR)
CHECK_SYMBOL_EXISTS(strtok_r      "${CURL_INCLUDES}" HAVE_STRTOK_R)
CHECK_SYMBOL_EXISTS(strftime      "${CURL_INCLUDES}" HAVE_STRFTIME)
CHECK_SYMBOL_EXISTS(uname         "${CURL_INCLUDES}" HAVE_UNAME)
CHECK_SYMBOL_EXISTS(strcasecmp    "${CURL_INCLUDES}" HAVE_STRCASECMP)
CHECK_SYMBOL_EXISTS(stricmp       "${CURL_INCLUDES}" HAVE_STRICMP)
CHECK_SYMBOL_EXISTS(strcmpi       "${CURL_INCLUDES}" HAVE_STRCMPI)
CHECK_SYMBOL_EXISTS(strncmpi      "${CURL_INCLUDES}" HAVE_STRNCMPI)
CHECK_SYMBOL_EXISTS(basename      "${CURL_INCLUDES}" HAVE_BASENAME)
IF(NOT HAVE_STRNCMPI)
  SET(HAVE_STRCMPI)
ENDIF(NOT HAVE_STRNCMPI)
CHECK_SYMBOL_EXISTS(gethostbyaddr "${CURL_INCLUDES}" HAVE_GETHOSTBYADDR)
CHECK_SYMBOL_EXISTS(gettimeofday  "${CURL_INCLUDES}" HAVE_GETTIMEOFDAY)
CHECK_SYMBOL_EXISTS(inet_addr     "${CURL_INCLUDES}" HAVE_INET_ADDR)
# windows only has this for vista, but will link with it and say
# that it has it at link time!  So, force it off
IF(WIN32)
  SET(HAVE_INET_PTON 0 CACHE "" INTERNAL )
ENDIF(WIN32)
CHECK_SYMBOL_EXISTS(inet_pton     "${CURL_INCLUDES}" HAVE_INET_PTON)
CHECK_SYMBOL_EXISTS(inet_ntoa     "${CURL_INCLUDES}" HAVE_INET_NTOA)
CHECK_SYMBOL_EXISTS(inet_ntoa_r   "${CURL_INCLUDES}" HAVE_INET_NTOA_R)
CHECK_SYMBOL_EXISTS(tcsetattr     "${CURL_INCLUDES}" HAVE_TCSETATTR)
CHECK_SYMBOL_EXISTS(tcgetattr     "${CURL_INCLUDES}" HAVE_TCGETATTR)
CHECK_SYMBOL_EXISTS(perror        "${CURL_INCLUDES}" HAVE_PERROR)
CHECK_SYMBOL_EXISTS(closesocket   "${CURL_INCLUDES}" HAVE_CLOSESOCKET)
CHECK_SYMBOL_EXISTS(setvbuf       "${CURL_INCLUDES}" HAVE_SETVBUF)
CHECK_SYMBOL_EXISTS(sigsetjmp     "${CURL_INCLUDES}" HAVE_SIGSETJMP)
CHECK_SYMBOL_EXISTS(getpass_r     "${CURL_INCLUDES}" HAVE_GETPASS_R)
CHECK_SYMBOL_EXISTS(getpwuid      "${CURL_INCLUDES}" HAVE_GETPWUID)
CHECK_SYMBOL_EXISTS(geteuid       "${CURL_INCLUDES}" HAVE_GETEUID)
CHECK_SYMBOL_EXISTS(utime         "${CURL_INCLUDES}" HAVE_UTIME)
IF(CMAKE_USE_OPENSSL)
  CHECK_SYMBOL_EXISTS(RAND_status   "${CURL_INCLUDES}" HAVE_RAND_STATUS)
  CHECK_SYMBOL_EXISTS(RAND_screen   "${CURL_INCLUDES}" HAVE_RAND_SCREEN)
  CHECK_SYMBOL_EXISTS(RAND_egd      "${CURL_INCLUDES}" HAVE_RAND_EGD)
  CHECK_SYMBOL_EXISTS(CRYPTO_cleanup_all_ex_data "${CURL_INCLUDES}"
    HAVE_CRYPTO_CLEANUP_ALL_EX_DATA)
ENDIF(CMAKE_USE_OPENSSL)
CHECK_SYMBOL_EXISTS(gmtime_r      "${CURL_INCLUDES}" HAVE_GMTIME_R)
CHECK_SYMBOL_EXISTS(localtime_r   "${CURL_INCLUDES}" HAVE_LOCALTIME_R)

CHECK_SYMBOL_EXISTS(gethostbyname   "${CURL_INCLUDES}" HAVE_GETHOSTBYNAME)
CHECK_SYMBOL_EXISTS(gethostbyname_r "${CURL_INCLUDES}" HAVE_GETHOSTBYNAME_R)
CHECK_SYMBOL_EXISTS(gethostbyaddr_r "${CURL_INCLUDES}" HAVE_GETHOSTBYADDR_R)

CHECK_SYMBOL_EXISTS(signal        "${CURL_INCLUDES}" HAVE_SIGNAL_FUNC)
CHECK_SYMBOL_EXISTS(SIGALRM       "${CURL_INCLUDES}" HAVE_SIGNAL_MACRO)
IF(HAVE_SIGNAL_FUNC AND HAVE_SIGNAL_MACRO)
  SET(HAVE_SIGNAL 1)
ENDIF(HAVE_SIGNAL_FUNC AND HAVE_SIGNAL_MACRO)
CHECK_SYMBOL_EXISTS(uname          "${CURL_INCLUDES}" HAVE_UNAME)
CHECK_SYMBOL_EXISTS(strtoll        "${CURL_INCLUDES}" HAVE_STRTOLL)
CHECK_SYMBOL_EXISTS(_strtoi64      "${CURL_INCLUDES}" HAVE__STRTOI64)
CHECK_SYMBOL_EXISTS(strerror_r     "${CURL_INCLUDES}" HAVE_STRERROR_R)
CHECK_SYMBOL_EXISTS(siginterrupt   "${CURL_INCLUDES}" HAVE_SIGINTERRUPT)
CHECK_SYMBOL_EXISTS(perror         "${CURL_INCLUDES}" HAVE_PERROR)
CHECK_SYMBOL_EXISTS(fork           "${CURL_INCLUDES}" HAVE_FORK)
CHECK_SYMBOL_EXISTS(pipe           "${CURL_INCLUDES}" HAVE_PIPE)
CHECK_SYMBOL_EXISTS(ftruncate      "${CURL_INCLUDES}" HAVE_FTRUNCATE)
CHECK_SYMBOL_EXISTS(getprotobyname "${CURL_INCLUDES}" HAVE_GETPROTOBYNAME)
CHECK_SYMBOL_EXISTS(getrlimit      "${CURL_INCLUDES}" HAVE_GETRLIMIT)
CHECK_SYMBOL_EXISTS(idn_free       "${CURL_INCLUDES}" HAVE_IDN_FREE)
CHECK_SYMBOL_EXISTS(idna_strerror  "${CURL_INCLUDES}" HAVE_IDNA_STRERROR)
CHECK_SYMBOL_EXISTS(tld_strerror   "${CURL_INCLUDES}" HAVE_TLD_STRERROR)
CHECK_SYMBOL_EXISTS(setlocale      "${CURL_INCLUDES}" HAVE_SETLOCALE)
CHECK_SYMBOL_EXISTS(setrlimit      "${CURL_INCLUDES}" HAVE_SETRLIMIT)

# only build compat strtok if we need to
IF (NOT HAVE_STRTOK_R)
  SET(libCurl_SRCS ${libCurl_SRCS}
    strtok.c
    )
ENDIF (NOT HAVE_STRTOK_R)

# only build compat strtoofft if we need to
IF(NOT HAVE_STRTOLL AND NOT HAVE__STRTOI64)
  SET(libCurl_SRCS ${libCurl_SRCS}
    strtoofft.c
    )
ENDIF(NOT HAVE_STRTOLL AND NOT HAVE__STRTOI64)

# sigaction and sigsetjmp are special. Use special mechanism for
# detecting those, but only if previous attempt failed.
IF(HAVE_SIGNAL_H)
  CHECK_SYMBOL_EXISTS(sigaction "signal.h" HAVE_SIGACTION)
ENDIF(HAVE_SIGNAL_H)

IF(NOT HAVE_SIGSETJMP)
  IF(HAVE_SETJMP_H)
    CHECK_SYMBOL_EXISTS(sigsetjmp "setjmp.h" HAVE_MACRO_SIGSETJMP)
    IF(HAVE_MACRO_SIGSETJMP)
      SET(HAVE_SIGSETJMP 1)
    ENDIF(HAVE_MACRO_SIGSETJMP)
  ENDIF(HAVE_SETJMP_H)
ENDIF(NOT HAVE_SIGSETJMP)

# For other curl specific tests, use this macro.
MACRO(CURL_INTERNAL_TEST CURL_TEST)
  IF("${CURL_TEST}" MATCHES "^${CURL_TEST}$")
    SET(MACRO_CHECK_FUNCTION_DEFINITIONS
      "-D${CURL_TEST} ${CMAKE_REQUIRED_FLAGS}")
    IF(CMAKE_REQUIRED_LIBRARIES)
      SET(CURL_TEST_ADD_LIBRARIES
        "-DLINK_LIBRARIES:STRING=${CMAKE_REQUIRED_LIBRARIES}")
    ENDIF(CMAKE_REQUIRED_LIBRARIES)

    MESSAGE(STATUS "Performing Curl Test ${CURL_TEST}")
    TRY_COMPILE(${CURL_TEST}
      ${CMAKE_BINARY_DIR}
      ${LIBCURL_SOURCE_DIR}/CMake/CurlTests.c
      CMAKE_FLAGS -DCOMPILE_DEFINITIONS:STRING=${MACRO_CHECK_FUNCTION_DEFINITIONS}
      "${CURL_TEST_ADD_LIBRARIES}"
      OUTPUT_VARIABLE OUTPUT)
    IF(${CURL_TEST})
      SET(${CURL_TEST} 1 CACHE INTERNAL "Curl test ${FUNCTION}")
      MESSAGE(STATUS "Performing Curl Test ${CURL_TEST} - Success")
      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log
        "Performing Curl Test ${CURL_TEST} passed with the following output:\n"
        "${OUTPUT}\n")
    ELSE(${CURL_TEST})
      MESSAGE(STATUS "Performing Curl Test ${CURL_TEST} - Failed")
      SET(${CURL_TEST} "" CACHE INTERNAL "Curl test ${FUNCTION}")
      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log
        "Performing Curl Test ${CURL_TEST} failed with the following output:\n"
        "${OUTPUT}\n")
    ENDIF(${CURL_TEST})
  ENDIF("${CURL_TEST}" MATCHES "^${CURL_TEST}$")
ENDMACRO(CURL_INTERNAL_TEST)

# Do curl specific tests
#OPTION(CURL_HAVE_DISABLED_NONBLOCKING "Disable non-blocking socket detection" OFF)
SET(CURL_NONBLOCKING_TESTS)
IF(NOT CURL_HAVE_DISABLED_NONBLOCKING)
  SET(CURL_NONBLOCKING_TESTS
    HAVE_FIONBIO
    HAVE_IOCTLSOCKET
    HAVE_IOCTLSOCKET_CASE
    HAVE_O_NONBLOCK
    HAVE_SO_NONBLOCK
    )
ENDIF(NOT CURL_HAVE_DISABLED_NONBLOCKING)
FOREACH(CURL_TEST
    ${CURL_NONBLOCKING_TESTS}
    TIME_WITH_SYS_TIME
    HAVE_O_NONBLOCKHAVE_GETHOSTBYADDR_R_5
    HAVE_GETHOSTBYADDR_R_7
    HAVE_GETHOSTBYADDR_R_8
    HAVE_GETHOSTBYADDR_R_5_REENTRANT
    HAVE_GETHOSTBYADDR_R_7_REENTRANT
    HAVE_GETHOSTBYADDR_R_8_REENTRANT
    HAVE_GETHOSTBYNAME_R_3
    HAVE_GETHOSTBYNAME_R_5
    HAVE_GETHOSTBYNAME_R_6
    HAVE_GETHOSTBYNAME_R_3_REENTRANT
    HAVE_GETHOSTBYNAME_R_5_REENTRANT
    HAVE_GETHOSTBYNAME_R_6_REENTRANT
    HAVE_SOCKLEN_T
    HAVE_IN_ADDR_T
    STDC_HEADERS
    RETSIGTYPE_TEST
    HAVE_INET_NTOA_R_DECL
    HAVE_INET_NTOA_R_DECL_REENTRANT
    HAVE_GETADDRINFO
    HAVE_FILE_OFFSET_BITS
    )
  CURL_INTERNAL_TEST(${CURL_TEST})
ENDFOREACH(CURL_TEST)
IF(HAVE_FILE_OFFSET_BITS)
  SET(_FILE_OFFSET_BITS 64)
ENDIF(HAVE_FILE_OFFSET_BITS)

# Check for reentrant
FOREACH(CURL_TEST
    HAVE_GETHOSTBYADDR_R_5
    HAVE_GETHOSTBYADDR_R_7
    HAVE_GETHOSTBYADDR_R_8
    HAVE_GETHOSTBYNAME_R_3
    HAVE_GETHOSTBYNAME_R_5
    HAVE_GETHOSTBYNAME_R_6
    HAVE_INET_NTOA_R_DECL_REENTRANT)
  IF(NOT ${CURL_TEST})
    IF(${CURL_TEST}_REENTRANT)
      SET(NEED_REENTRANT 1)
    ENDIF(${CURL_TEST}_REENTRANT)
  ENDIF(NOT ${CURL_TEST})
ENDFOREACH(CURL_TEST)

IF(NEED_REENTRANT)
  FOREACH(CURL_TEST
      HAVE_GETHOSTBYADDR_R_5
      HAVE_GETHOSTBYADDR_R_7
      HAVE_GETHOSTBYADDR_R_8
      HAVE_GETHOSTBYNAME_R_3
      HAVE_GETHOSTBYNAME_R_5
      HAVE_GETHOSTBYNAME_R_6)
    SET(${CURL_TEST} 0)
    IF(${CURL_TEST}_REENTRANT)
      SET(${CURL_TEST} 1)
    ENDIF(${CURL_TEST}_REENTRANT)
  ENDFOREACH(CURL_TEST)
ENDIF(NEED_REENTRANT)

IF(HAVE_INET_NTOA_R_DECL_REENTRANT)
  SET(HAVE_INET_NTOA_R_DECL 1)
  SET(NEED_REENTRANT 1)
ENDIF(HAVE_INET_NTOA_R_DECL_REENTRANT)

# Some other minor tests

IF(NOT HAVE_SOCKLEN_T)
  SET(socklen_t "int")
ENDIF(NOT HAVE_SOCKLEN_T)

IF(NOT HAVE_IN_ADDR_T)
  SET(in_addr_t "unsigned long")
ENDIF(NOT HAVE_IN_ADDR_T)

# Fix libz / zlib.h

IF(NOT CURL_SPECIAL_LIBZ)
  IF(NOT HAVE_LIBZ)
    SET(HAVE_ZLIB_H 0)
  ENDIF(NOT HAVE_LIBZ)

  IF(NOT HAVE_ZLIB_H)
    SET(HAVE_LIBZ 0)
  ENDIF(NOT HAVE_ZLIB_H)
ENDIF(NOT CURL_SPECIAL_LIBZ)

IF(_FILE_OFFSET_BITS)
  SET(_FILE_OFFSET_BITS 64)
ENDIF(_FILE_OFFSET_BITS)
SET(CMAKE_REQUIRED_FLAGS "-D_FILE_OFFSET_BITS=64")
SET(CMAKE_EXTRA_INCLUDE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/curl/curl.h")
CHECK_TYPE_SIZE("curl_off_t" SIZEOF_CURL_OFF_T)
SET(CMAKE_EXTRA_INCLUDE_FILES)
SET(CMAKE_REQUIRED_FLAGS)


# Check for nonblocking
SET(HAVE_DISABLED_NONBLOCKING 1)
IF(HAVE_FIONBIO OR
    HAVE_IOCTLSOCKET OR
    HAVE_IOCTLSOCKET_CASE OR
    HAVE_O_NONBLOCK)
  SET(HAVE_DISABLED_NONBLOCKING)
ENDIF(HAVE_FIONBIO OR
  HAVE_IOCTLSOCKET OR
  HAVE_IOCTLSOCKET_CASE OR
  HAVE_O_NONBLOCK)

IF(RETSIGTYPE_TEST)
  SET(RETSIGTYPE void)
ELSE(RETSIGTYPE_TEST)
  SET(RETSIGTYPE int)
ENDIF(RETSIGTYPE_TEST)

IF(CMAKE_COMPILER_IS_GNUCC AND APPLE)
  INCLUDE(CheckCCompilerFlag)
  CHECK_C_COMPILER_FLAG(-Wno-long-double HAVE_C_FLAG_Wno_long_double)
  IF(HAVE_C_FLAG_Wno_long_double)
    # The Mac version of GCC warns about use of long double.  Disable it.
    GET_SOURCE_FILE_PROPERTY(MPRINTF_COMPILE_FLAGS mprintf.c COMPILE_FLAGS)
    IF(MPRINTF_COMPILE_FLAGS)
      SET(MPRINTF_COMPILE_FLAGS "${MPRINTF_COMPILE_FLAGS} -Wno-long-double")
    ELSE(MPRINTF_COMPILE_FLAGS)
      SET(MPRINTF_COMPILE_FLAGS "-Wno-long-double")
    ENDIF(MPRINTF_COMPILE_FLAGS)
    SET_SOURCE_FILES_PROPERTIES(mprintf.c PROPERTIES
      COMPILE_FLAGS ${MPRINTF_COMPILE_FLAGS})
  ENDIF(HAVE_C_FLAG_Wno_long_double)
ENDIF(CMAKE_COMPILER_IS_GNUCC AND APPLE)

INCLUDE(CMake/OtherTests.cmake)

# The rest of the build

OPTION(CMAKE_BUILD_CURL_SHARED "Should curl be built shared" TRUE)
IF(CMAKE_BUILD_CURL_SHARED)
  SET(LIBRARY_TYPE SHARED)
  ADD_DEFINITIONS(-DHAVE_CONFIG_H)
ELSE(CMAKE_BUILD_CURL_SHARED)
   ADD_DEFINITIONS(-DHAVE_CONFIG_H
    -DCURL_STATICLIB)
ENDIF(CMAKE_BUILD_CURL_SHARED)
SET(CURL_STATICLIB)

# Support CheckTypeSize module from CMake 2.8.0 and lower.
FOREACH(var
    SIZEOF_CURL_OFF_T
    SIZEOF_LONG
    SIZEOF_LONG_LONG
    SIZEOF___INT64
    SIZEOF_SIZE_T
    SIZEOF_SSIZE_T
    SIZEOF_TIME_T
    )
  IF(NOT ${var}_CODE)
    MESSAGE("creating ${var}_CODE")
    IF(${var})
      SET(${var}_CODE "#define ${var} ${${var}}")
    ELSE()
      SET(${var}_CODE "/* #undef ${var} */")
    ENDIF()
  ENDIF()
ENDFOREACH()

CONFIGURE_FILE(${LIBCURL_SOURCE_DIR}/config.h.in
  ${LIBCURL_BINARY_DIR}/config.h)

ADD_LIBRARY(cmcurl ${LIBRARY_TYPE} ${libCurl_SRCS} ${CMAKE_CURL_SSL_DLLS})
TARGET_LINK_LIBRARIES(cmcurl ${CURL_LIBS})
IF(CMAKE_BUILD_CURL_SHARED)
  SET_TARGET_PROPERTIES(cmcurl PROPERTIES DEFINE_SYMBOL BUILDING_LIBCURL
    RUNTIME_OUTPUT_DIRECTORY ${CMake_BIN_DIR})
  INSTALL(TARGETS cmcurl RUNTIME DESTINATION bin)
ENDIF(CMAKE_BUILD_CURL_SHARED)

OPTION(CURL_TESTING "Do libCurl testing" OFF)
IF(CURL_TESTING)
  SUBDIRS(Testing)
ENDIF(CURL_TESTING)

ADD_EXECUTABLE(LIBCURL Testing/curltest.c)
TARGET_LINK_LIBRARIES(LIBCURL cmcurl ${CMAKE_DL_LIBS})

IF(CMAKE_CURL_TEST_URL)
  ADD_TEST(curl LIBCURL ${CMAKE_CURL_TEST_URL})
ENDIF(CMAKE_CURL_TEST_URL)

INSTALL(FILES COPYING DESTINATION ${CMAKE_DOC_DIR}/cmcurl)
